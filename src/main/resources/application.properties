spring.application.name=E-Commerce Cineplus BACKEND

# ===================================================================
# SERVER CONFIGURATION
# ===================================================================
server.port=8080

# ===================================================================
# DATABASE CONFIGURATION (PostgreSQL - Neon)
# ===================================================================
# Using Neon Postgres connection. The provided psql URL:
# psql 'postgresql://neondb_owner:...@ep-crimson-term-.../neondb?sslmode=require&channel_binding=require'
# We set the JDBC URL, username and password separately for Spring Boot.
# Note: keep credentials secret in production (use env vars or secrets manager).
spring.datasource.url=jdbc:postgresql://ep-crimson-term-adj8ui9z-pooler.c-2.us-east-1.aws.neon.tech:5432/neondb?sslmode=require&channelBinding=require
spring.datasource.username=neondb_owner
spring.datasource.password=npg_o3ZevJXbi1Wl
spring.datasource.driver-class-name=org.postgresql.Driver

# ===================================================================
# JPA / HIBERNATE CONFIGURATION
# ===================================================================
# IMPORTANTE: ddl-auto=update
# - Hibernate genera/actualiza AUTOMÁTICAMENTE todas las tablas al iniciar
# - NO necesitas ejecutar scripts SQL manualmente
# - Tablas generadas: users, roles, movies, cinemas, theaters, seats, 
#   showtimes, seat_reservations, payment_methods, purchases, purchase_items,
#   concession_products, etc.
# 
# Opciones de ddl-auto:
# - update: Actualiza schema sin borrar datos (RECOMENDADO para desarrollo)
# - create: Borra y recrea tablas cada vez (CUIDADO: pierdes datos)
# - create-drop: Crea al iniciar, borra al cerrar
# - validate: Solo valida que el schema coincida
# - none: No hace nada (solo para producción con migraciones manuales)
spring.jpa.hibernate.ddl-auto=update 
spring.jpa.show-sql=true 
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true

# ===================================================================
# SECURITY CONFIGURATION (JWT)
# ===================================================================
# IMPORTANTE: Clave secreta para firmar tokens JWT
# - jwt.secret: Debe ser de al menos 256 bits (32 caracteres)
# - jwt.expiration: Tiempo de expiración en milisegundos (86400000 = 24 horas)
# - CAMBIAR en producción a una clave más segura y almacenarla en variables de entorno
jwt.secret=UnaClaveSecretaMuyLargaYSeguraParaJWTQueDebeSerDeAlMenos256Bits
jwt.expiration=86400000

# ===================================================================
# CORS CONFIGURATION
# ===================================================================
# IMPORTANTE: URLs permitidas para solicitudes desde el frontend
# - http://localhost:5173: Vite dev server (puerto principal)
# - http://localhost:5174: Vite dev server (puerto alternativo)
# 
# Si el frontend cambia de puerto o se despliega en producción:
# 1. Actualizar spring.web.cors.allowed-origins
# 2. Actualizar @CrossOrigin en todos los controladores
# 3. Verificar SecurityConfig.java (usa estos valores con Customizer.withDefaults())
spring.web.cors.allowed-origins=http://localhost:5173, https://hdd-frontend.onrender.com
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*
spring.web.cors.allow-credentials=true

# ===================================================================
# REDIS CONFIGURATION (Cache & Sessions)
# ===================================================================
# IMPORTANTE: Redis se usa para:
# - Caché de reservas de asientos temporales (15 minutos)
# - Gestión de sesiones de usuario
# - Para desarrollo local: localhost:6379
# - Para producción: Cambiar a URL de Redis en la nube
spring.data.redis.host=localhost
spring.data.redis.port=6379